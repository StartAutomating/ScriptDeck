<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 2.0.3: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>LoupeDeck.Profile</Name>
    <Members>
      <ScriptProperty>
        <Name>Controls</Name>
        <GetScriptBlock>
                        $placesWithControls = 
    @(
        $this.layout
        $this.layout.layoutModes
    )

foreach ($controlHolder in $placesWithControls) {
    foreach ($layoutProperty in $controlHolder.psobject.properties) {
        if ($layoutProperty.Name -like '*Pages') {
            foreach ($v in $layoutProperty.Value) {
                if ($v.PressAction) {
                    $v.PressAction
                }
                if ($v.RotateAction) {
                    $v.RotateAction
                }
                
                if ($v.controls) {
                    foreach ($ctrl in $v.controls) {
                        if ($ctrl.PressAction) {
                            $ctrl.PressAction
                        }
                        if ($ctrl.RotateAction) {
                            $ctrl.RotateAction
                        }
                    }
                }
            }
        }
    }
}


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>LastModified</Name>
        <GetScriptBlock>
                        $this.LastModifiedTimeUtc.ToLocalTime()
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>ScriptDeck.Action</Name>
    <Members>
      <ScriptMethod>
        <Name>ClearImage</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Clears a ScriptDeck action's image
.DESCRIPTION
    Clears any dynamically provided image applied to a ScriptDeck action.

    Images assigned thru the StreamDeck UI will always take precedence.

    If one has been provided in the UI, this will not change it.
#&gt;
param()

$exportPath = Join-Path ($this.Plugin.PluginPath | Split-Path) -ChildPath "$($this.Context).setTitle.Send-StreamDeck.clixml"
Export-Clixml -InputObject @{
    EventName = 'setImage'
    Context = $this.Context
    Payload = @{
        "image" = ''
    }
} -Path $exportPath

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ClearSettings</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Clears action settings
.DESCRIPTION
    Clears all settings related to this ScriptDeck action
#&gt;
$mySettings = $this.Settings
$toSet  = [Ordered]@{}
foreach ($settingsProperty in @($mySettings.psobject.properties)) {
    $toSet[$settingsProperty.Name] = $null
}
$this.Settings = $toSet

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ClearTitle</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Clears a ScriptDeck action's title
.DESCRIPTION
    Clears any dynamically provided title applied to a ScriptDeck action.

    Titles assigned thru the StreamDeck UI will always take precedence.

    If one has been provided in the UI, this will not change it.
#&gt;
param()

$exportPath = Join-Path ($this.Plugin.PluginPath | Split-Path) -ChildPath "$($this.Context).setTitle.Send-StreamDeck.clixml"
Export-Clixml -InputObject @{
    EventName = 'setTitle'
    Context = $this.Context
    Payload = @{
        "title" = ''
    }
} -Path $exportPath

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>SetImage</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Sets an action's image
.DESCRIPTION
    Sets a dynamic image for an action.
.NOTES
    The StreamDeck api only allow for a static image to be provided.
    If an animated .gif is provided, only it's first frame will be used.
#&gt;
param(
# The path to the image
[string]
$ImagePath
)

$exportPath = Join-Path ($this.Plugin.PluginPath | Split-Path) -ChildPath "$($this.Context).setTitle.Send-StreamDeck.clixml"
Export-Clixml -InputObject @{
    Context = $this.Context
    ImagePath = $ImagePath
} -Path $exportPath

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>SetSVG</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Sets an Action's Image to SVG
.DESCRIPTION
    Sets an Action's Image to inline SVG.
.NOTES
    StreamDeck does not currently support advanced SVG features.
#&gt;
param(
$SvgContent
)


if ($svgContent -is [xml] -or $SvgContent -is [xml.xmlelement]) {
    $SvgContent = $SvgContent.OuterXml
}

$exportPath = Join-Path ($this.Plugin.PluginPath | Split-Path) -ChildPath "$($this.Context).setImage.Send-StreamDeck.clixml"
Export-Clixml -InputObject @{
    EventName = 'setImage'
    Context = $this.Context
    Payload = @{
        "image" = "data:image/svg+xml;charset=utf8,$SvgContent"
    }
} -Path $exportPath

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>SetTitle</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Sets a ScriptDeck action's title
.DESCRIPTION
    Sets a dynamically provided title to a ScriptDeck action.

    Titles assigned thru the StreamDeck UI will always take precedence.

    If one has been provided in the UI, this will not change it.
#&gt;
param(
# The title of the StreamDeck action.
[string]
$Title
)

$this | Add-Member '.Title' $Title -Force
$exportPath = Join-Path ($this.Plugin.PluginPath | Split-Path) -ChildPath "$($this.Context).setTitle.Send-StreamDeck.clixml"
Export-Clixml -InputObject @{
    Context = $this.Context
    Title = $Title
} -Path $exportPath

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ShowAlert</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Shows an Alert
.DESCRIPTION
    Sends a 'ShowAlert' message to StreamDeck, which will show a warning icon briefly atop of an action.
#&gt;
$exportPath = Join-Path ($this.Plugin.PluginPath | Split-Path) -ChildPath "$($this.Context).showAlert.Send-StreamDeck.clixml"
Export-Clixml -InputObject @{
    Context = $this.Context
    ShowAlert = $true
} -Path $exportPath

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ShowOK</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Shows an OK
.DESCRIPTION
    Sends a 'ShowOK' message to StreamDeck, which will show a checkmark briefly atop of an action.
#&gt;
param()
$exportPath = Join-Path ($this.Plugin.PluginPath | Split-Path) -ChildPath "$($this.Context).showAlert.Send-StreamDeck.clixml"
Export-Clixml -InputObject @{
    Context = $this.Context
    ShowOK = $true
} -Path $exportPath

                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>ActionID</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the ActionID
.DESCRIPTION
    Gets the Action Identifier for a StreamDeck action.
#&gt;
@($this.Action -split '\.')[-1]
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Column</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an Action's Column
.DESCRIPTION
    Gets the column of a StreamDeck action
#&gt;
$this.payload.coordinates.column
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Controller</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an action's controller
.DESCRIPTION
    Gets the associated controller for an action.
#&gt;
$this.payload.Controller
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>DeviceName</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the device name
.DESCRIPTION
    Gets the friendly name of the StreamDeck device associated to an action.
#&gt;
if (-not $this.'.DeviceInfo') {
    if (-not $script:streamDeckDevices) {
        $script:streamDeckDevices = (Get-ScriptDeck).StreamDeckDevices
    }
    
    $this | Add-Member NoteProperty '.DeviceInfo' ($script:streamDeckDevices | Where-Object DeviceID -eq $this.device) -Force
}

$this.'.DeviceInfo'.Name
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>EventFile</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Get an action's event files  
.DESCRIPTION
    Get the event files related to an action.
    These contain the StreamDeck messages sent to the action.
#&gt;
@(Get-ChildItem -Path (Split-Path $this.Plugin.PluginPath) -Filter "*.$($this.Context).received.clixml" | Sort-Object LastWriteTime -Descending) 
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>HasStaticTitle</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Determines if a title has been set
.DESCRIPTION
    Determines if the title for a StreamDeck action has changed.
#&gt;
'' -ne $this.LastTitleChange.title
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>History</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets a ScriptDeck action's history
.DESCRIPTION
    Gets all events related to a particular ScriptDeck action,
    from most recent to least recent.
#&gt;
param()

$foundFiles = @(Get-ChildItem -Path (Split-Path $this.Plugin.PluginPath) -Filter "*.$($this.Context).received.clixml")

if ($this.'.HistoryFileCount' -ne $foundFiles.Length) {
    $foundFiles = @($foundFiles | Sort-Object LastWriteTime -Descending)
    $updatedHistory = @(
        if (-not $this.'.History' -or ($this.'.History'.Length -lt $foundFiles.Length)) {
            foreach ($foundFile in $foundFiles) {
                Import-Clixml -Path $foundFile.FullName
            }
        }
        else {
            foreach ($foundFile in $foundFiles[0..($foundFiles.Length - $this.'.History'.Length)]) {
                Import-Clixml -Path $foundFile.FullName
            }            
        }        
    )
    

    $this | Add-Member NoteProperty '.HistoryFileCount' $foundFiles.Length -Force
    $this | Add-Member NoteProperty '.History' $updatedHistory -Force
}

$this.'.History'
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>LastTitleChange</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets the last title change
.DESCRIPTION
    Gets the last change to the title of a ScriptDeck action.
#&gt;
$this.History | 
    Where-Object { $_.MessageData.event -eq 'titleParametersDidChange' } |
    Select-Object -First 1 |
    ForEach-Object { $_.MessageData.Payload }
    
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Row</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets an Action's Row
.DESCRIPTION
    Gets the row of a StreamDeck action
#&gt;
$this.payload.coordinates.row
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Settings</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets settings for an action
.DESCRIPTION
    Gets the settings for a StreamDeck action
.NOTES
    If the action is updated manually, these may be out of sync.
#&gt;
param()

if ($this.Payload.Settings) {
    $this.Payload.Settings
}

                    </GetScriptBlock>
        <SetScriptBlock>
                        &lt;#
.SYNOPSIS
    Set StreamDeck action settings
.DESCRIPTION
    Changes the settings for a StreamDeck action
#&gt;
param(
# Any updated settings
$Value
)

if ($Value) {
    if ($value -is [Collections.IDictionary]) {
        foreach ($kv in $Value.GetEnumerator()) {
            $settingValue = $kv.Value
            if ($settingValue -is [scriptblock]) {
                $settingValue = "$settingValue"
            }
            $this.Payload.Settings | Add-Member NoteProperty $kv.Key $kv.Value -Force
        }
    } elseif ($value -isnot [Object[]]) {
        foreach ($prop in $value.psobject.properties) {
            $settingValue = $kv.Key
            if ($settingValue -is [scriptblock]) {
                $settingValue = "$settingValue"
            }
            $this.Payload.Settings | Add-Member NoteProperty $kv.Name $kv.Value -Force
        }
    }
}

$exportPath = Join-Path ($this.Plugin.PluginPath | Split-Path) -ChildPath "$($this.Context).setSettings.Send-StreamDeck.clixml"
Export-Clixml -InputObject @{
    Context = $this.Context
    EventName = 'setSettings'
    Payload = $this.Payload.Settings
} -Path $exportPath

# Send-StreamDeck -Context $event.MessageData.Context -EventName setSettings -Payload $newSettings
                    </SetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>StreamDeck.Device</Name>
    <Members>
      <ScriptProperty>
        <Name>Columns</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets device row count
.DESCRIPTION
    Gets the number of rows on a StreamDeck device
#&gt;
$this.Size.Columns
                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Rows</Name>
        <GetScriptBlock>
                        &lt;#
.SYNOPSIS
    Gets device row count
.DESCRIPTION
    Gets the number of rows on a StreamDeck device
#&gt;
$this.size.rows
                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
  <Type>
    <Name>StreamDeck.Profile</Name>
    <Members>
      <ScriptMethod>
        <Name>AddAction</Name>
        <Script>
                        param(
[PSTypeName('StreamDeck.Action')]
$Action,

[int]
$Row = -1,

[int]
$Column = -1
)

$maxRows, $maxCols = $this.DeviceSize
$foundSpot = 
    if ($Row -lt 0) {
        :foundRow for ($r = 0; $r -lt $maxRows; $r++) {        
            if ($Column -lt 0) {
                for ($c =0 ; $c -lt $maxCols; $c++) {
                    if (-not $this.Actions."$c,$r") {
                        $r, $C
                        break foundRow
                    }
                }                           
            } else {
                if (-not $this.Actions."$Column,$r") {
                    $r, $Column
                    break foundRow
                }        
            }    
        }        
    } elseif ($Column -lt 0) {
        for ($c =0 ; $c -lt $maxCols; $c++) {
            if (-not $this.Actions."$c,$Row") {
                $Row, $c
                break
            }
        }
    } else {
        $row, $Column
    }


if (-not $foundSpot) {
    throw "Unable to find a location. Row: $row Column: $Column"
}

$r, $c = $foundSpot
Add-Member -MemberType NoteProperty "$c,$r" -Value $action -InputObject $this.Actions -Force
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>RemoveAction</Name>
        <Script>
                        param(
[Parameter(Mandatory)]
[string]
$Row,
[Parameter(Mandatory)]
[string]
$Column
)

$obj = $this
$toRemove = @($obj.actions.psobject.properties | Select-Object -ExpandProperty Name |
    Where-Object {
        $c, $r = $_ -split ','
        $colRow  = ''+  $c + "," + $r
        $colRow -like "$column,$Row"
    })

foreach ($tr in $toRemove) {
    $obj.actions.psobject.properties.Remove($tr)
}

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Save</Name>
        <Script>
                        if (-not $this.Path) { throw "Cannot save profile, as it has no path" }

&lt;#$streamdeckprocess = Get-Process streamdeck -ErrorAction SilentlyContinue
$streamDeckPath    = "$($streamdeckprocess.Path)"
if ($streamDeckPath) { 
    Start-Process -FilePath $streamDeckPath -ArgumentList '--quit' -Wait
}#&gt;
#$streamdeckprocess | Stop-Process

foreach ($action in $this.Actions.psobject.properties) {
    $stateIndex = 0
    $actionImagePath  = $this.Path | 
        Split-Path | 
        Join-Path -ChildPath $action.Name |
        Join-Path -ChildPath CustomImages

    if ($action.value.uuid -in 'com.elgato.streamdeck.page.next', 'com.elgato.streamdeck.profile.openchild') {
        
        if ($action.value.settings.pstypenames -contains 'StreamDeck.Profile') {
            $childPluginPath = $action.value.settings.guid
            $root = $(if ($this.IsChild) {
                $this.Parent
            } else {
                $this
            })
            $childRoot = $root | 
                Split-Path | 
                Join-Path -ChildPath Profiles | 
                Join-Path -ChildPath "$($action.value.settings.guid).sdProfile" |
                Join-Path -ChildPath "manifest.json"
            
            $childPlugin = $action.value.settings | Add-Member NoteProperty Path "$childRoot" -Force -PassThru
            $childPlugin.Save()
            $action.value.settings = [PSCustomObject]@{ProfileUUID=$childPlugin.guid}
        }
    }
    foreach ($state in $action.value.states) {
        
        if ($state.Image) {
            if ($state.Image -match '^http(?:s)?://') {
                $imageUri = [uri]$state.Image
                $fileName = $imageUri.Segments[-1]
                
                $destinationPath  =  Join-Path $actionImagePath $fileName
                if (-not (Test-Path $destinationPath)) {
                    $null = New-Item -ItemType File -Path $destinationPath -Force
                }
                [Net.Webclient]::new().DownloadFile($imageUri, $destinationPath)
                $state.image = $fileName
            }
            elseif ($state.Image.Contains([IO.Path]::DirectorySeparatorChar) -and 
                -not $state.Image.ToLower().StartsWith($this.Path.ToLower)
            ) {
                $resolvedImagePath  = $ExecutionContext.SessionState.Path.GetResolvedPSPathFromPSPath($state.Image)
                if (-not $resolvedImagePath) {
                    Write-Warning "Could not update image for $($action.Name)"
                    continue
                }
                $fileName = [IO.Path]::GetFileName("$resolvedImagePath")
                $destinationPath  =  Join-Path $actionImagePath $fileName
                if (-not (Test-Path $destinationPath)) {
                    $null = New-Item -ItemType File -Path $destinationPath -Force
                }
                Copy-Item -Path $resolvedImagePath -Destination $destinationPath -Force
                $state.Image = $fileName
            }
        }
        $stateIndex++
    }
}
$scriptPropertyNames = $this.psobject.properties | Where-Object MemberType -EQ ScriptProperty | Select-Object -ExpandProperty Name -Unique
$excludedProperties = @('Path','GUID') + $scriptPropertyNames

if (-not (Test-Path $this.Path)) {
    $createdProfile = New-Item -ItemType File -Path $this.Path -Force
}

$this |
    Select-Object -Property * -ExcludeProperty $excludedProperties| 
    ConvertTo-Json -Depth 100 | 
    Set-Content -literalPath $this.Path -Encoding UTF8
                    </Script>
      </ScriptMethod>
      <ScriptProperty>
        <Name>Children</Name>
        <GetScriptBlock>
                        if (-not $this.HasChildren) { return }
@(if ($this.IsChild) {
    $this.Parent | 
        Split-Path |
        Join-Path -child Profiles 
} else {
    $this | 
        Split-Path |
        Join-Path -child Profiles 
}) | 
    Get-ChildItem | 
    Get-StreamDeckProfile -ProfileRoot {$_.fullname } 

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ColumnCount</Name>
        <GetScriptBlock>
                        switch ($this.DeviceName) {
    StreamDeckXL { 8 }
    StreamDeckMini { 3 }
    StreamDeckMobile { 5 }
    StreamDeck { 5 }
    'Corsair G6 Keyboard' { 1 }
}


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>DeviceName</Name>
        <GetScriptBlock>
                        switch ($this.DeviceModel) {
    20GAI9901  { "StreamDeckMini" }
    20GAT9901  { "StreamDeckXL" }
    20GAA9901  { "StreamDeck" }
    20GAA9902  { "StreamDeck" } 
    'VSD/WiFi' { "StreamDeckMobile" }
    default { $this.DeviceModel }
}

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>DeviceSize</Name>
        <GetScriptBlock>
                        switch ($this.DeviceName) {
    StreamDeckXL { 4,8 }
    StreamDeckMini { 2,3 }
    StreamDeckMobile { 3,5 }
    StreamDeck { 3,5 }
    'Corsair G6 Keyboard' { 6,1 }
}



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>HasChildren</Name>
        <GetScriptBlock>
                        foreach ($act in $this.Actions.psobject.properties) {
    if ($act.value.uuid -in 'com.elgato.streamdeck.profile.openchild') {
        return $true
    }
}

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>HasPages</Name>
        <GetScriptBlock>
                        foreach ($act in $this.Actions.psobject.properties) {
    if ($act.value.uuid -in 'com.elgato.streamdeck.page.previous','com.elgato.streamdeck.page.next') {
        return $true
    }
}

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>IsChild</Name>
        <GetScriptBlock>
                        if (-not $this.Path) { return $true }
($this.Path | Split-Path | Split-Path | Split-Path | Split-Path -Leaf) -ne 'StreamDeck'

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>NextPage</Name>
        <GetScriptBlock>
                        foreach ($act in $this.Actions.psobject.properties) {
    if ($act.value.uuid -in 'com.elgato.streamdeck.page.next') {
        if ($this.Path) {
            $this.Path | 
                ForEach-Object {
                    if ($this.IsChild) {
                        $_ | Split-Path | Split-Path
                    } else {
                        $_ | Split-Path | Join-Path -ChildPath Profiles 
                    }
                } |                
                Join-Path -ChildPath "$($act.value.settings.profileUUID).sdProfile" |
                Get-StreamDeckProfile -ProfileRoot { $_ }            
        }
    }
}


                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>PageNumber</Name>
        <GetScriptBlock>
                        if (-not $this.HasPages) { return 1 }
if (-not $this.IsChild)  { return 1 }
$page = $this.Parent
$pageNumber = 1
while ($page -and $page.Path -ne $this.Path) {
    $pageNumber++
    $page = $page.NextPage
}
if ($page) {
    $pageNumber
} else {
    return 0
}

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>Parent</Name>
        <GetScriptBlock>
                        if (-not $this.IsChild) { return $null }
($this.Path | Split-Path | Split-Path | Split-Path | Get-StreamDeckProfile -ProfileRoot { $_ })



                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>ProfilePath</Name>
        <GetScriptBlock>
                        return $this.Path

                    </GetScriptBlock>
      </ScriptProperty>
      <ScriptProperty>
        <Name>RowCount</Name>
        <GetScriptBlock>
                        switch ($this.DeviceName) {
    StreamDeckXL { 4 }
    StreamDeckMini { 2 }
    StreamDeckMobile { 3 }
    StreamDeck { 3 }
    'Corsair G6 Keyboard' { 6 }
}

                    </GetScriptBlock>
      </ScriptProperty>
    </Members>
  </Type>
</Types>
